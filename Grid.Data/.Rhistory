y <- MG$Rainfall[MS$Month!=0]
x <- MS$Precipitation[MS$Month!=0]
if(class(x[1])=="factor"){
x <- levels(x)[x]
x <- as.numeric(x)
}
if(class(y[1])=="factor"){
y <- levels(y)[y]
y <- as.numeric(y)
}
mod <- lm(y ~ x)
beta0 <- mod$coefficient[1]
beta1 <- mod$coefficients[2]
Lon <- MS$Longitude[1]
Lat <- MS$Latitude[1]
Station <- MS$Station[1]
s <- summary(mod)$sigma
n <- length(MS$Precipitation)
Dist2Coast <- mean(D2C[D2C[,1] < Lon + 0.02 & D2C[,1] > Lon - 0.02 & D2C[,2] > Lat - 0.02 & D2C[,2] < Lat + 0.02,3])
Xl <- rbind(Xl, cbind(beta0, beta1, Lat, Lon, Station, s, n, Solar.1[[i]], Dist2Coast))
if(i%%100==0){
print(i)
}
}, error = function(e){})
}
row.names(Xl) <- NULL
colnames(Xl) <- c("beta0", "beta1", "Lat", "Lon", "Station", "s", "n", "Solar")
hist(Xl$beta2)
Xl <- as.data.frame(Xl)
Xl <- Xl[which(Xl[,4]!=0),]
Xl <- Xl[complete.cases(Xl),]
Xl <- Xl[Xl[,4]>100,]
Xl <- Xl[Xl[,2] >-0.5, ]
Xl <- Xl[Xl[,1]< 50,]
Xl <- Xl[Xl[,7] > 12,]
colnames(Xl) <- c("beta0", "beta1", "Lat", "Lon", "Station", "s", "n", "Solar", "D2C")
Xl <- as.data.frame(Xl)
Xl <- Xl[which(Xl[,4]!=0),]
Xl <- Xl[complete.cases(Xl),]
Xl <- Xl[Xl[,4]>100,]
Xl <- Xl[Xl[,2] >-0.5, ]
Xl <- Xl[Xl[,1] < 50,]
Xl <- Xl[Xl[,7] > 12,]
lel1 <- getData('alt', country='AUS', mask=TRUE)
lel2 <- extract(lel1, cbind(Xl$Lon, Xl$Lat))
lel3 <- c(13.1, 10.3, 9.2, 15.7, 150.6, 14.1, 19.3, 6.8, 11.6, 2.7, 11.4, 26.8,
16.1, 32.2, 6.7, 6.8, 12.8, 6.5, 9.6, 1.5, 9.8, 13, 74.6, 27.4,
5.6, 9.5, 13.6, 0.1, 4.4, 8.6, 8.6, 11.1, 10.6, 0, 14.9, 3.8, 0,
11.6, 4.7, 26.2, 5.3, 8.1, 3.7, 25.3, 60.8)
Xl <- cbind(Xl, lel2)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 6)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 7)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl0), method = "eigen")
5
summary(modl0)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 5)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 6)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl0), method = "eigen")
nbl1 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 7)) #k=10 gives best model for slope with huber's
modl1 <- lagsarlm(beta1 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl1), method = "eigen")
summary(modl1)
nbl1 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 6)) #k=10 gives best model for slope with huber's
modl1 <- lagsarlm(beta1 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl1), method = "eigen")
summary(modl1)
nbl1 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 8)) #k=10 gives best model for slope with huber's
modl1 <- lagsarlm(beta1 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl1), method = "eigen")
5
summary(modl1)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 7)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ 1, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
nbl0 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 6)) #k=9 gives best model for intercept with huber's
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C, data = Xl, listw = nb2listw(nbl0), method = "eigen")
5
summary(modl0)
nbl1 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 8)) #k=10 gives best model for slope with huber's
modl1 <- lagsarlm(beta1 ~ D2C, data = Xl, listw = nb2listw(nbl1), method = "eigen")
summary(modl1)
head(Xl)
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C + Lat + Lon, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C + Lat*Lon, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
modl0 <- lagsarlm(beta0 ~ Solar + lel2 + D2C + Lat, data = Xl, listw = nb2listw(nbl0), method = "eigen")
summary(modl0)
Xnew <- cbind(modl0$fitted.values,Xl[,3:4])
Xl <- as.data.frame(Xl)
hist(Xl[,1])
hist(Xl[,2])
Xnew <- cbind(modl0$fitted.values,Xl[,3:4])
summary(modl0$fitted.values)
length(modl0$fitted.values)
Xl <- Xl[complete.cases(Xl),]
Xnew <- cbind(modl0$fitted.values,Xl[,3:4])
Y <- cbind(Xl[,1], Xl[,3], Xl[,4])
Y <- rbind(Y, c(min(Xnew[,1]),0,0), c(max(Xnew[,1]),0,0))
Xnew1 <- Xnew
Xnew1 <- rbind(Xnew1, c(max(Y[,1]),0,0), c(min(Y[,1]),0,0))
plot(newmap, xlim = c(109.4,154.6), ylim = c(-43.65,-10.58), main = "Intercept")
scatter2D(Xnew1[,3], Xnew1[,2], colvar = Xnew1[,1], add = TRUE, cex = 0.2, colkey = list( side = 2))
plot(newmap, xlim = c(109.4,154.6), ylim = c(-43.65,-10.58), main = "Intercept")
scatter2D(Xl[,4],Xl[,3], colvar = Xl[,1], add = TRUE, cex = 0.2, colkey = list( side = 2)) #Plotting the intercept
nbl1 <- knn2nb(knearneigh(cbind(Xl$Lon, Xl$Lat), k = 7)) #k=10 gives best model for slope with huber's
modl1 <- lagsarlm(beta1 ~ D2C + Lat + Lon, data = Xl, listw = nb2listw(nbl1), method = "eigen")
summary(modl1)
Xnew <- cbind(modl1$fitted.values,Xl[,3:4])
Y <- cbind(Xl[,2], Xl[,3], Xl[,4])
Y <- rbind(Y, c(min(Xnew[,1]),0,0), c(max(Xnew[,1]),0,0))
Xnew1 <- Xnew
Xnew1 <- rbind(Xnew1, c(max(Y[,1]),0,0), c(min(Y[,1]),0,0))
plot(newmap, xlim = c(113.4,158.6), ylim = c(-43.65,-10.58), main = "Slope")
scatter2D(Xnew1[,3], Xnew1[,2], colvar = Xnew1[,1], add = TRUE, cex = 0.2, colkey = list( side = 4))
plot(newmap, xlim = c(109.4,154.6), ylim = c(-43.65,-10.58), main = "Slope")
scatter2D(Xl[,4],Xl[,3], colvar = Xl[,2], add = TRUE, cex = 0.2, colkey = list( side = 2)) #Plotting the intercept
x <- rnorm(10)
y <- rnorm(10)
cov(x,y)
x
y
cov(cbind(x,y))
cov(x-y)
cov(x,y)
var(x,y)
var(x-y)
library(rgdal)
NEWS <- "http://svn.osgeo.org/metacrs/proj/trunk/proj/NEWS"
NEWS
PROJ4_NEWS <- readLines(url(NEWS))
lns <- grep("Release Notes|EPSG", PROJ4_NEWS) #pattern matching and replacement
help(grep)
head(PROJ4_NEWS[lns])
lns
EPSG <- make_EPSG()
help("make_EPSG")
EPSG[grep("^#ED50$", EPSG$note),]
ED50 <- CRS("+init=epsg:4230 +towgs84=-87,-96,-120,0,0,0,0")
ED50
IJ.east <- as(char2dms("4d31'00\"E"), "numeric")
IJ.east
IJ.north <- as(char2dms("52d28'00\"N"), "numeric")
IJ.ED50 <- SpatialPoints(cbind(x = IJ.east, y = IJ.north), proj4string = ED50)
res <- spTransform(IJ.ED50, CRS("+proj=longlat +datum=WGS84"))
x <- as(dd2dms(coordinates(res)[1]), "character")
y <- as(dd2dms(coordinates(res)[2], TRUE), "character")
cat(x, y, "\n")
spDistsN1(coordinates(IJ.ED50), coordinates(res), longlat = TRUE)*1000
library(maptools)
gzAzimuth(coordinates(IJ.ED50), coordinates(res))
help("spDists")
proj4string(IJ.ED50) <- CRS("+init=epsg:4230")
res <- spTransform(IJ.ED50, crs("+proj=longlat+ datum=WGS84"))
spDistsN1(coordinates(IJ.ED50), coordinates(res), longlat = TRUE)*1000
gzAzimuth(coordinates(IJ.ED50), coordinates(res))
EPSG[grep("Atlas", EPSG$note), 1:2]
head(ogrDrivers(), n = 10)
vignette("OGR_shape_encoding", package = "rgdal")
scot_dat <- read.table("scotland.dat", skip = 1)
install.packages("osmar")
library("osmar")
install.packages("RgoogleMaps")
library(RgoogleMaps)
install.packages("OpenStreetMap")
library("OpenStreetMap")
myMap <- GetMap(center = c(60.395, 5.322), zoom = 16, destfile = "MyTile2.png", maptype = "mobile")
BB <- do.call("rbind", myMap$BBOX)
dBB <- rev(diff(BB))
myMap1 <- GetMap.OSM(lonR = c(5.319, 5.328), latR = c(60.392, 60.398), scale = 4000, destfile = "MyTile.png")
library(spatstat)
data("japanesepines")
summary(japanesepines)
plot(japanesepines)
help("japanesepines")
library(maptools)
spjpines <- as(japanesepines, "SpatialPoints")
summary(spjpines)
plot(spjpines)
spjpines1 <- elide(spjpines, scale = TRUE, unitsq = TRUE)
summary(spjpines1)
plot(spjpines1)
pppjap <- as(spjpines1, "ppp")
summary(pppjap)
library(rgdal)
spasthma <- readOGR(".", "spasthma")
help(readOGR)
data.dir <- "/Users/nicholasnagle/Dropbox/classes/geog_515_s12/Data/north_derby"
spasthma <- readOGR(dsn = data.dir, "spasthma")  # asthma point data
library(sp)
set.seed(1998)
r <- seq(0, sqrt(2)/6, by = 0.005)
envjap <- envelope(as(spjpines1, "ppp"), fun = Gest, r = r, nrank = 2, nsim = 99)
plot(envjap)
envcells <- envelope(as(spcells, "ppp"), fun = Gest, r = r, nrank = 2, nsim = 99)
library(lattice)
library(sp)
data(meuse)
coordinates(meuse) <- c("x", "y")
spplot(meuse, "zinc", do.log = T, colorkey = TRUE)
bubble(meuse, "zinc", do.log = T, key.space = "bottom")
meuse
xyplot(log(zinc) ~ sqrt(dist), as.data.frame(meuse))
zn.lm <- lm(log(zinc) ~ sqrt(dist), meuse)
meuse$fitted.s <- predict(zn.lm, meuse) - mean(predict(zn.lm, meuse))
meuse$residuals <- residuals(zn.lm)
spplot(meuse, c("fitted.s","residuals"))
data(meuse.grid)
coordinates(meuse.grid) <- c("x", "y")
meuse.grid <- as(meuse.grid, "SpatialPixelsDataFrame")
library(gstat)
idw.out <- gstat::idw(zinc ~ 1, meuse, meuse.grid, idp = 2.5)
idw.out
as.data.frame(idw.out)[1:5,]
#Linear Regression
zn.lm <- lm(log(zinc) ~ sqrt(dist), meuse)
zn.lm
plot(zn.lm)
meuse.grid$se.fit <- predict(zn.lm, meuse.grid, se.fit = TRUE)$se.fit
library(gstat)
help(krige)
meuse.lm <- krige(log(zinc)~sqrt(dist), meuse, meuse.grid)
meuse.lm
plot(meuse.lm)
meuse.tr2 <- krige(log(zinc) ~ 1, meuse, meuse.grid, degree = 2)
plot(meuse.tr2)
zn.lm2 <- lm(log(zinc) ~ poly(x,y, degree = 2), meuse)
plot(zn.lm)
install.packages("ade4")
install.packages("spdep")
library("spdep")
install.packages("spdep")
library(rgdal)
NY8 <- readOGR(".", "NY8_utm18")
if (require(rgdal, quietly = TRUE)) {
NY8 <- readOGR(system.file("shapes/NY8_utm18.shp", package = "spData"))
} else {
require(maptools, quietly = TRUE)
NY8 <- readShapeSpatial(system.file("shapes/NY8_utm18.shp", package = "spData"))
}
NY_nb <- read.gal(system.file("weights/NY_nb.gal", package = "spData"),
region.id = row.names(NY8))
summary(NY_nb)
plot(NY8, border = "grey60")
plot(NY_nb, coordinates(NY8), pch=19, cex = 0.6, add = TRUE)
Syracuse <- NY8[NY8$AREANAME== "Syracuse city",]
par(mfrow = c(1,1))
summary(NY_nb)
plot(NY8, border = "grey60")
plot(NY_nb, coordinates(NY8), pch=19, cex = 0.6, add = TRUE)
Syracuse <- NY8[NY8$AREANAME== "Syracuse city",]
Sy0_nb <- subset(NY_nb, NY8$AREANAME == "Syracuse city")
summary(Sy0_nb)
coords <- coordinates(Syracuse)
IDs <- row.names(Syracuse)
Sy8_nb <- knn2nb(knearneigh(coords, k = 1), row.names = IDs)
Sy9_nb <- knn2nb(knearneigh(coords, k = 2), row.names = IDs)
Sy10_nb <- knn2nb(knearneigh(coords, k = 4), row.names = IDs)
dsts <- unlist(nbdists(Sy8_nb, coords))
Sy11_nb <- dnearneigh(coords, d1 = 0, d2 = 0.75*max(dsts), row.names = IDs)
Sy8_nb
Sy9_nb
Sy10_nb
Sy11_nb
Sy0_lw_W <- nb2listw(Sy0_nb)
Sy0_lw_W
names(Sy0_lw_W)
#Fitting Model of Areal Data
nylm <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8)
summary(nylm)
NY8$lmresid <- residuals(nylm)
sum((NY8$Z-nylm$fitted.values)^2)/length(NY8$Z)
library(spdep)
NYlistw <- nb2listw(NY_nb, style = "B")
lm.morantest(nylm, NYlistw)
NYlistwW <- nb2listw(NY_nb, style = "W")
aple(residuals(nylm), listw = NYlistwW)
m1 <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, listw = NYlistwW)
nysar <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, listw = NYlistw)
summary(nysar)
nylmw <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, weights = POP8)
summary(nylmw)
NY8$lmwresid <- residuals(nylmw)
lm.morantest(nylmw, NYlistw)
nysarw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, listw = NYlistw, weights = POP8)
summary(nysarw)
nycar <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, family = "CAR", listw = NYlistw)
summary(nycar)
nycarw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, family = "CAR", listw = NYlistw, weights = POP8)
summary(nycarw)
nysarwM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = NY8, family = "SAR", listw = NYlistw, weights = POP8, method = "Matrix")
summary(nysarwM)
nhdatafile <- "data/NHD2016.xlsx"
install.packages("rio")
nhdata <- rio::import(datafile)
library(sf)
library(raster)
library(dplyr)
library(spData)
install.packages("sf")
library(sf)
library(tmap)    # for static and interactive maps
install.packages("tmap")
install.packages("tmap")
library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(mapview) # for interactive maps
library(ggplot2) # tidyverse vis package
library(shiny)
tm_shape(nz) +
tm_borders()
tm_shape(aus) +
tm_borders()
help(tm_shape)
if (require("maps")) {
ia <- map_data("county", "iowa")
mid_range <- function(x) mean(range(x))
seats <- plyr::ddply(ia, "subregion", plyr::colwise(mid_range, c("lat", "long")))
ggplot(ia, aes(long, lat)) +
geom_polygon(aes(group = group), fill = NA, colour = "grey60") +
geom_text(aes(label = subregion), data = seats, size = 2, angle = 45)
data(us.cities)
capitals <- subset(us.cities, capital == 2)
ggplot(capitals, aes(long, lat)) +
borders("state") +
geom_point(aes(size = pop)) +
scale_size_area() +
coord_quickmap()
# Same map, with some world context
ggplot(capitals, aes(long, lat)) +
borders("world", xlim = c(-130, -60), ylim = c(20, 50)) +
geom_point(aes(size = pop)) +
scale_size_area() +
coord_quickmap()
}
tm_shape(AUS) +
tm_borders()
tm_shape(World, projection="longlat")
data(World, metro, rivers)
tm_shape(World, projection="longlat")
tm_shape(World, projection="longlat") +
tm_polygons() +
tm_layout("Long lat coordinates (WGS84)", inner.margins=c(0,0,.1,0), title.size=.8)
World$highlighted <- ifelse(World$iso_a3 %in% c("GRL", "AUS"), "gold", "gray75")
tm_shape(World, projection="merc", ylim=c(.1, 1), relative = TRUE) +
tm_polygons("highlighted") +
tm_layout("Web Mercator projection. Although widely used, it is discouraged for
statistical purposes. In reality, Australia is 3 times larger than Greenland!",
inner.margins=c(0,0,.1,0), title.size=.6)
tm_shape(World, projection="robin") +
tm_polygons() +
tm_layout(
"Winkel-Tripel projection, adapted as default by the National Geographic Society for world maps.",
inner.margins=c(0,0,.1,0), title.size=.8)
tm_shape(World) +
tm_polygons() +
tm_layout("Eckhart IV projection. Recommended in statistical maps for its equal-area property.",
inner.margins=c(0,0,.1,0), title.size=.8)
tm1 <- tm_shape(World, simplify = 0.05) + tm_polygons() + tm_layout("Simplification: 0.05")
tm2 <- tm_shape(World, simplify = 0.1) + tm_polygons() + tm_layout("Simplification: 0.1")
tm3 <- tm_shape(World, simplify = 0.25) + tm_polygons() + tm_layout("Simplification: 0.25")
tm4 <- tm_shape(World, simplify = 0.5) + tm_polygons() + tm_layout("Simplification: 0.5")
require(tmaptools)
tmap_arrange(tm1, tm2, tm3, tm4)
## End(Not run)
# three groups of layers, each starting with tm_shape
## Not run:
tm_shape(World) +
tm_fill("darkolivegreen3") +
tm_shape(metro) +
tm_bubbles("pop2010", col = "grey30", scale=.5) +
tm_shape(rivers) +
tm_lines("lightcyan1") +
tm_layout(bg.color="lightcyan1", inner.margins=c(0,0,.02,0), legend.show = FALSE)
mu <- rnorm(100,25,3) + rep(1:10,10)
beta <- rnorm(100)
mu
mu <- matrix(rnorm(100,25,3) + rep(1:10,10),10,10)
beta <- matrix(rep(rnorm(10),10),10,10)
beta
mu
gamma <- matrix(rep(rnorm(10),10),10,10, byrow = TRUE)
gamma
#No spatio-temporal interaction
Y <- mu + beta + gamma
plot(Y)
Y
Y <- as.matrix(Y)
heatmap(Y)
help(heatmap)
W <- matrix(c(0),10,10)
W <- matrix(c(0),10,10)
for(i in 1:9){
for(j in (i+1):10){
W[i,j] <- 1/abs(i-j)
}
}
W <- t(W) + W
W
kappa <- W%*%(mu + beta + gamma)
kappa
kappa <- W%*%(mu + beta + gamma)/10
kappa
Y <- mu + beta + gamma + kappa
Y <- as.matrix(Y)
heatmap(Y)
require(lattice)
#The lattice package provides a dataset named volcano. It's a square matrix looking like that :
head(volcano)
# The use of levelplot is really easy then :
levelplot(volcano)
levelplot(Y)
Y
levelplot(t(Y))
dim(volcano)
mean(W)
kappa <- W%*%(mu + beta + gamma)-mean(W)
kappa
kappa <- W%*%(mu + beta + gamma)-mean(W%*%(mu + beta + gamma))
kappa
Y <- mu + beta + gamma + kappa
Y <- as.matrix(Y)
levelplot(t(Y))
library(rgdal)
library(spdplyr)
install.packages("spdplyr")
library(spdplyr)
library(geojsonio)
install.packages("geojsonio")
library(geojsonio)
library(rmapshaper)
install.packages("rmapshaper")
library(rmapshaper)
# Load Australian State and Territories shapefile data
aus_ste <- readOGR(dsn = "/Users/kannishida/Downloads/STE11aAust", layer = "STE11aAust")
# Load Australian State and Territories shapefile data
aus_ste <- readOGR(dsn = "/Users/bhines/Downloads/1259030001_ste11aaust_shape/STE11aAust.shp", layer = "STE11aAust")
# Convert to GeoJSON
aus_ste_json <- geojson_json(aus_ste)
# Simplify the polygons to reduce the size
aus_ste_sim <- ms_simplify(aus_ste_json)
# Write GeoJSON file out to a file system
geojson_write(aus_ste_sim, file = "/Users/bhines/Downloads/1259030001_ste11aaust_shape")
aus_ste_sim
library(maps)
df <- world.cities[world.cities$country.etc == "Australia",]
plot(df[, c("long", "lat")])
ggmap(myMap) +
geom_point(data = df[, c("long","lat", "pop")], aes(x=long, y = lat, colour = pop > 1000000)
ggmap(myMap) +
geom_point(data = df[, c("long","lat", "pop")], aes(x=long, y = lat, colour = pop > 1000000)
)
myMap <- get_map(location = "Australia", zoom = 4)
library(ggmap)
myMap <- get_map(location = "Australia", zoom = 4)
ggmap(myMap) +
geom_point(data = df[, c("long","lat", "pop")], aes(x=long, y = lat, colour = pop > 1000000))
library(leaflet)
## define a palette for hte colour
pal <- colorNumeric(palette = "YlOrRd",
domain = df$pop)
leaflet(data = df) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~long, popup = ~name,
color = ~pal(pop), stroke = FALSE, fillOpacity = 0.6) %>%
addLegend(position = "bottomleft", pal = pal, values = ~pop)
myMap <- get_map(location = "Australia", zoom = 4)
help(get_map)
long
## define a palette for hte colour
pal <- colorNumeric(palette = "YlOrRd",
domain = df$pop)
leaflet(data = df) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~long, popup = ~name,
color = ~pal(pop), stroke = FALSE, fillOpacity = 0.6) %>%
addLegend(position = "bottomleft", pal = pal, values = ~pop)
pop
pal(pop)
plot(df[, c("long", "lat")])
myMap <- get_map(location = c(lon = -95.3632715, lat = 29.7632836), zoom = 4)
Aus_cities= world.cities[world.cities$country.etc == "Australia",]
class(Aus_cities)
plot(Aus_cities[Aus_cities@data$pop>1000000,],pch=16,col="red",cex=3,add=TRUE)
pal
leaflet(data = df) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~long, popup = ~name,
color = ~pal(pop), stroke = FALSE, fillOpacity = 0.6) %>%
addLegend(position = "bottomleft", pal = pal, values = ~pop)
leaflet(data = df) %>%
addTiles() %>%
addCircleMarkers(lat = ~lat, lng = ~long, popup = ~name,
color = ~pal(pop), stroke = FALSE, fillOpacity = 1) %>%
addLegend(position = "bottomleft", pal = pal, values = ~pop)
help("addCircleMarkers")
library(sp)
library(raster)
# download uk data level 2 from GADM
uk <- getData('GADM', country='GBR', level = 2)
help("getData")
# download uk data level 2 from GADM
uk <- getData(country='GBR', level = 2)
getData('GADM', country='FRA', level=1)
library(raster)
getData('GADM', country='FRA', level=1)
getData(name = "FRA")
getData('alt', country='FRA', mask=TRUE)
el1 <- getData('alt', country='FRA', mask=TRUE)
el1 <- getData('alt', country='AUS', mask=TRUE)
el1
